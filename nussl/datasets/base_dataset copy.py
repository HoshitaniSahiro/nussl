from torch.utils.data import Dataset
import pickle
import librosa
import numpy as np
import os
import shutil
import random
from typing import Dict, Any, Optional, Tuple, List
from ...core import AudioSignal, jupyter_utils
from ...separation import SoftMask
from scipy.io import wavfile
import logging
import copy
from enum import Enum
import zarr
import numcodecs
import matplotlib.pyplot as plt
import soundfile as sf

class BaseDataset(Dataset):
    def __init__(self, folder: str, options: Dict[str, Any]):
        """Implements a variety of methods for loading source separation
        datasets such as WSJ0-[2,3]mix and datasets made with Scaper.

        Arguments:
            folder - Folder where dataset is contained.

        Keyword Arguments:
            options - a dictionary containing the settings for the dataset
                loader. See `config/defaults/metadata/dataset.json` for full
                description.
        """

        self.folder = folder
        self.options = copy.deepcopy(options)
        self.use_librosa = self.options.pop('use_librosa_stft', False)
        self.dataset_tag = self.options.pop('dataset_tag', 'default')
        self.current_length = self.options.pop('min_length', self.options['length'])
        self.excerpt_selection_strategy = self.options.pop('excerpt_selection_strategy', 'random')
        self.chunk_size = self.options.pop('chunk_size', 1)

        self.files = self.get_files(self.folder)
        random.shuffle(self.files)
        self.cached_files = []
        self.targets = [
            'log_spectrogram',
            'magnitude_spectrogram',
            'assignments',
            'source_spectrograms',
            'weights'
        ]
        self.data_keys_for_training = self.options.pop('data_keys_for_training', [])
        self.targets += self.data_keys_for_training
        self.targets = list(set(self.targets))
        self.setup_cache()
        self.cache_populated = False

        if self.options['fraction_of_dataset'] < 1.0:
            num_files = int(
                len(self.files) * self.options['fraction_of_dataset']
            )
            self.files = self.files[:num_files]

    def setup_cache(self):
        """Items generated by the dataset can be cached using zarr. Zarr is a
        library for easily storing data in efficient and compressed structures. 
        Every time BaseDataset's __getitem__ method is called, it returns a 
        dictionary with keys and values (usually numpy arrays but they can be 
        anything). If self.options['cache'] points to some place (is a string of
        nonzero length), then a cache is created. The name of the cache follows 
        a specific format, allowing for cache reuse. It uses the dataset location
        with underscores instead of /, and appends the dataset_tag, kept in 
        self.options['dataset_tag'], and adds the extension '.zarr'. The location
        will be printed by the logging.
        """
        if self.options['cache']:
            cache = os.path.join(
                os.path.expanduser(self.options['cache']),
                '_'.join(self.folder.split('/')),
                self.dataset_tag + '.zarr'
            )
            self.cache = cache
            self.overwrite_cache = self.options.pop('overwrite_cache', False)
            logging.info(f'Caching to: {self.cache}')

            file_mode = 'r'
            if os.path.exists(self.cache):
                logging.info(f'Cache location {self.cache} exists! Checking if overwrite. Otherwise, will use cache.')
                if self.overwrite_cache:
                    logging.info('Overwriting cache.')
                    self.clear_cache()
                    file_mode = 'w'
            else:
                logging.info(f'{self.cache} does not exist...creating a new cache')
                self.overwrite_cache = True
                file_mode = 'w'
            
            self.cache_dataset = zarr.open(
                self.cache, 
                mode=file_mode, 
                shape=(len(self),), 
                chunks=(self.chunk_size,),
                dtype=object, 
                object_codec=numcodecs.Pickle(),
                synchronizer=zarr.ThreadSynchronizer(),
            )

    def clear_cache(self):
        """Deletes the cache.
        """
        logging.info(f'Clearing cache: {self.cache}')
        shutil.rmtree(self.cache, ignore_errors=True)
    
    def populate_cache(self, filename, i):
        """Generates an example and puts it in the cache.
        """
        output = self._generate_example(filename)
        if self.data_keys_for_training:
            output = {
                k: output[k] for k in output 
                if k in self.data_keys_for_training
            }
        self.write_to_cache(output, i)
        return self.get_target_length(output, self.current_length)

    def switch_to_cache(self):
        """In the first pass through the data, the cache is created on the fly. On
        subsequent epochs, you should use `switch_to_cache` to switch to the cache.
        This function closes and reopens the cache in read-only mode, and sets the 
        internal flag cache_populated to True. Now future reads are done via the
        cache.
        """
        self.cache_dataset = zarr.open(
            self.cache, 
            mode='r', 
            shape=(len(self.files),), 
            chunks=(self.chunk_size,),
            dtype=object, 
            object_codec=numcodecs.Pickle(),
            synchronizer=zarr.ThreadSynchronizer(),
        )
        self.cache_populated = True

    def write_to_cache(self, data_dict, i):
        """Writes a dictionary of keys and values to a location in the cache.
        """
        self.cache_dataset[i] = data_dict

    def load_from_cache(self, i):
        """Reads the ith dictionary from the cache.
        """
        data = self.cache_dataset[i]
        return self.get_target_length(data, self.current_length)
            
    def get_files(self, folder):
        """This function must be implemented by whatever class inherits BaseDataset.
        It should return a list of files in the given folder, each of which is 
        processed by load_audio_files in some way to produce mixes, sources, class
        labels, etc.

        Args:
            folder - location that should be processed to produce the list of files.

        Returns:
            list of files
        """
        raise NotImplementedError()

    def load_audio_files(
            self,
            filename: str
        ) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """Each file returned by get_files is processed by this function. For example,
        if each file is a json file containing the paths to the mixture and sources, 
        then this function should parse the json file and load the mixture and sources
        and return them.

        Exact behavior of this functionality is determined by implementation by subclass.

        Args:
            filename - name of file to load

        Returns:
            Depends on sub-class. Should return at least the mixture and the constituent
            sources.
        """
        raise NotImplementedError()

    def __len__(self) -> int:
        """Gets number of examples"""
        return len(self.files)

    def __getitem__(self, i: int) -> Dict[str, Any]:
        """Gets one item from dataset

        Args:
            i - index of example to get

        Returns:
            one data point (an output dictionary containing the data comprising
            one example)
        """
        return self._get_item_helper(self.files[i], self.cache, i)

    def _get_item_helper(
        self,
        filename: str,
        cache: Optional[str],
        i: int = -1,
    ) -> Dict[str, Any]:
        """Gets one item from dataset

        If `cache` is None, will generate an example (training|validation) from
        scratch. If `cache` is not None, it will attempt to read from the path
        given by `cache`. On failure it will write to the path given by `cache`
        for subsequent reads.

        Args:
            filename - name of file corresponding to current example
            cache - `None` or path to cache folder
            i - index of current example (used only in cache filename
                generation). Defaults to -1 (should only be `-1` when `cache` is
                `None`)

        Returns:
            one data point (an output dictionary containing the data comprising
            one example)
        """
        if self.cache:
            if self.cache_populated:
                output = self.load_from_cache(i)
            else:
                output = self.populate_cache(filename, i)
        else:
            output = self._generate_example(filename)
            output = self.get_target_length(output, self.current_length)
            
        return output

    def _generate_example(self, filename: str) -> List[Dict[str, Any]]:
        """Generates one example (training|validation) from given filename

        Args:
            filename - name of audio file from which to generate example

        Returns:
            one data point (an output dictionary containing the data comprising
            one example)
        """
        mix, sources, classes = self.load_audio_files(filename)
        output = self.construct_input_output(mix, sources)
        output['weights'] = self.get_weights(
            output,
            self.options['weight_type']
        )
        output['log_spectrogram'] = self.whiten(output['log_spectrogram'])
        output['classes'] = classes
        output = self.transpose_pad_and_filter(
            output,
            self.options['length']
        )
        return output

    def whiten(self, data):
        """Optionally preprocess the data in some way (e.g. make zero mean and unit 
        variance). In Base class, this function does nothing, but it can be overridden
        by a subclass.

        Args:
            data - nparray containing the data

        Returns:
            Processed version of data.
        """
        return data

    def construct_input_output(self, mix, sources):
        """Given a mixture signal and source signals, each represented as AudioSignal
        object, construct the input and the output for a neural network. This 
        implementation of this function is capable of computing many different types
        of outputs, depending on the setting in self.options['output_type']:

            'msa': Produces the magnitude spectrum approximation [1]. A network trained
                   with this output will try to match the magnitudes of the ground 
                   truth source when masking the mixture.
            'psa': Produces the phase-sensitive spectrum approximation [1]. A network
                   trained with this output will try to create a mask of the mixture
                   that takes into account the phase information. This sometimes results
                   in higher separation performance.

        The output of these is stored in dictionary key 'source_spectrograms'.
        
        [1] Erdogan, Hakan, John R. Hershey, Shinji Watanabe, and Jonathan Le Roux. 
        "Phase-sensitive and recognition-boosted speech separation using 
        deep recurrent neural networks." In 2015 IEEE International Conference 
        on Acoustics, Speech and Signal Processing (ICASSP), pp. 708-712. IEEE, 
        2015.

        Args:
            mix - AudioSignal object containing the mixture.
            sources - list of AudioSignal objects containing the sources that sum to
                the mixture.

        Returns:
            A dictionary with four keys: 
                'log_spectrogram': The log-magnitude spectrogram of the mixture.
                'magnitude_spectrogram': The magnitude spectrogram of the mixture.
                'source_spectrograms': A numpy array containing the spectrograms that
                    the separation network should attempt to match. See 'psa' and 'msa'
                    description above.
                'assignments': The binary assignments for each time-frequency point. 
                    Useful for training deep clustering networks.
        """
        log_spectrogram, mix_stft = self.transform(mix)
        mix_magnitude = np.abs(mix_stft)
        source_magnitudes = []

        for source in sources:
            _, source_stft = self.transform(source)
            source_magnitude = np.abs(source_stft)

            if self.options['output_type'] == 'msa':
                source_magnitude = np.minimum(mix_magnitude, source_magnitude)
            elif self.options['output_type'] == 'psa':
                mix_phase = np.angle(mix_stft)
                source_phase = np.angle(source_stft)
                source_magnitude = np.maximum(
                    0.0,
                    np.minimum(
                        mix_magnitude,
                        source_magnitude * np.cos(source_phase - mix_phase),
                    )
                )
            source_magnitudes.append(source_magnitude)

        source_magnitudes = np.stack(source_magnitudes, axis=-1)
        shape = source_magnitudes.shape
        assignments = (
            source_magnitudes == np.amax(source_magnitudes, axis=-1, keepdims=True)
        ).astype(float)

        source_db = librosa.amplitude_to_db(source_magnitudes, ref=np.max)

        output = {
            'log_spectrogram': log_spectrogram,
            'magnitude_spectrogram': mix_magnitude,
            'assignments': assignments,
            'source_spectrograms': source_magnitudes,
        }

        return output
        
    def transpose_pad_and_filter(self, data_dict, max_length):
        """For training, each data point should be at least of some length, so that we
        can extract an excerpt that is of 'max_length'. The data is also transposed so
        that the length of the sequence is on the first axis and the number of features 
        is on the second axis. This function also filters the data dictionary so that
        keys that are not needed during training are not stored. For a key to be saved
        during training, it should be in self.options['data_keys_for_training'] 
        when initializing the dataset class. This is to reduce the size of the
        cache (which can get very big if you're not careful.)

        Args:
            data_dict: dictionary containing keys and values which are numpy arrays.
            max_length: The maximum length of a sequence you use during training.

        Returns:
            Dictionary containing keys and values that are transposed, 
            padded to the max_length, and filtered for unnecessary keys.
        """
        length = data_dict['log_spectrogram'].shape[1]
    
        for i, target in enumerate(self.targets):
            if not np.ndim(data_dict[target]) == 0:
                data = data_dict[target]
                pad_length = max(max_length - length, 0)
                pad_tuple = [(0, 0) for k in range(len(data.shape))]
                pad_tuple[1] = (0, pad_length)
                data_dict[target] = np.pad(data, pad_tuple, mode='constant')

        for target in self.targets:
            if self.data_keys_for_training and target not in self.data_keys_for_training:
                data_dict.pop(target)
            else:
                if not np.ndim(data_dict[target]) == 0:
                    data_dict[target] = np.swapaxes(data_dict[target], 0, 1)
        
        return data_dict
    
    def set_current_length(self, current_length):
        """The current length of sequences can be altered on the fly during training 
        via calls to this function. This is useful for implementing something like
        curriculum learning. You can start with sequences of length 100 and then switch
        to sequences of length 400 during training like so:

            # dset is an initialized subclass of BaseDataset
            dset.set_current_length(100)
            # train for 20 epochs
            dset.set_current_length(400)
            # train at longer length

        Args:
            current_length: length of training sequences.

        Returns:
            No effect. Sets self.current_length = current_length after some validation.
        """
        if current_length > self.options['length']:
            logging.warning(
                f"current_length={current_length} exceeds original "
                f"set max length {self.options['length']}. "
                f"Setting current_length to {self.options['length']}")
            current_length = self.options['length']
        self.current_length = current_length

    def get_target_length(self, data_dict, target_length):
        """Extracts sequences from each key, val pair in data_dict that match a
        given target_length. So if target_length is 400, all of the sequences will be
        400 frames long. There are two strategies for selecting excerpts from the
        training sequences:

            'random': Randomly select some offset between the start and the length of
                the sequence - the target length.
            'balanced': First filter all possible offsets to points where both sources
                are actually active. Then select randomly from this list. This is useful
                if you have sparse mixtures where the sources are sometimes overlapping
                in time and sometimes not. This strategy looks for when they are
                overlapping in time and tries to only return those excerpts. This can be
                important for training a separation algorithm.

        Args:
            data_dict: dictionary containing keys and values which are numpy arrays.
            target_length: The length of a sequence you want.
        
        Returns:
            A dictionary with each value trimmed to match the requested target_length.
        """
        length = data_dict['log_spectrogram'].shape[0]
        if self.excerpt_selection_strategy == 'random':
            offset = random.randint(0, length - target_length)
        elif self.excerpt_selection_strategy == 'balanced':
            _balance = data_dict['assignments'].mean(axis=-3).prod(axis=-1)
            indices = np.argwhere(_balance >= np.percentile(_balance, 50))[:, 0]
            indices[indices > length - target_length] = max(0, length - target_length)
            indices = np.unique(indices)
            offset = random.choice(indices)
                
        for target in data_dict:
            if target != 'classes' and not np.ndim(data_dict[target]) == 0:
                data_dict[target] = data_dict[target][
                    offset:offset + target_length,
                    :,
                    :self.options['num_channels']
                ]
        return data_dict

    def transform(self, audio_signal):
        """Uses nussl STFT to transform.

        Args:
            audio_signal {[np.ndarray]} -- AudioSignal object

        Returns:
            [tuple] -- (log_spec, stft). log_spec contains the
            log_spectrogram, stft contains the complex spectrogram
        """
        audio_signal.stft_data = None
        stft = (
            audio_signal.stft(use_librosa=self.use_librosa)
        )
        log_spectrogram = librosa.amplitude_to_db(np.abs(stft), ref=1.0)
        return log_spectrogram, stft


    def get_weights(self, data_dict, weight_type):
        """During training, the loss for every time-frequency bin can be weighted in
        different ways. There are several weighting schemes that are implemented in
        this function. See the staticmethods below for more information.

        Arguments:
            data_dict: dictionary containing keys and values which are numpy arrays.
            weight_type: a list of weighting schemes that you want. Each set of weights
                is multiplied against the other weights to combine them.
        Returns:
            The square root of the weights. This is to match the weighted 
            version of the deep clustering loss.

        """
        weights = np.ones(data_dict['magnitude_spectrogram'].shape)
        if ('magnitude' in weight_type):
            weights *= self.magnitude_weights(
                data_dict['magnitude_spectrogram']
            )
        elif ('source_magnitude' in weight_type):
            weights *= self.source_magnitude_weights(
                data_dict['source_spectrograms']
            )
        if ('threshold' in weight_type):
            weights *= self.threshold_weights(
                data_dict['log_spectrogram'],
                self.options['weight_threshold']
            )
        if ('class' in weight_type):
            weights *= self.class_weights(
                data_dict['assignments'],
            )
        if ('log' in weight_type):
            weights = np.log10(weights + 1)
        return np.sqrt(weights)

    @staticmethod
    def class_weights(assignments):
        """More common classes are weighted down while less common classes are weighted
        up.

        Args:
            assignments: returned by construct_input_output, a matrix that indicates the
                 assignment of every time-frequency point in the mixture spectrogram.
        
        Returns:
            Weights based on class frequency.
        """
        _shape = assignments.shape 
        assignments = assignments.reshape(-1, _shape[-1])

        class_weights = assignments.sum(axis=0)
        class_weights /= (class_weights.sum() + 1e-7)
        class_weights = 1 / np.sqrt(class_weights + 1e-4)

        weights = assignments @ class_weights 
        weights = weights.reshape(_shape[:-1])
        assignments.reshape(_shape)
        return weights

    @staticmethod
    def magnitude_weights(magnitude_spectrogram):
        """Loud points matter more than quiet points.

        Args:
            magnitude_spectrogram: returned by construct_input_output, a matrix indicating
                 magnitude (loudness) of each time-frequency bin.
        
        Returns:
            Weights based on loudness 
        """
        weights = magnitude_spectrogram / (np.sum(magnitude_spectrogram) + 1e-6)
        weights *= (
            magnitude_spectrogram.shape[0] * magnitude_spectrogram.shape[1]
        )
        return weights

    @staticmethod
    def threshold_weights(log_spectrogram, threshold=-40):
        """Quiet points don't matter.

        Args:
            log_spectrogram: returned by construct_input_output, a matrix indicating
                 log magnitude (dB) of each time-frequency bin.
            threshold: loudness threshold. Below this, weights will be 0.
        
        Returns:
            Weights for time-frequency bins below a given threshold are 0. 
        """
        return (log_spectrogram > threshold).astype(float)

    @staticmethod
    def source_magnitude_weights(source_spectrograms):
        """Loud points matter more than quiet points, but this time loudness is based
        on each source magnitude.

        Args:
            source_spectrograms: returned by construct_input_output, a matrix with 
                magnitude spectrograms for every source.
        
        Returns:
            Weights based on loudness of each source. 
        """
        weights = [
            self.magnitude_weights(source_spectrograms[..., i])
            for i in range(source_spectrograms.shape[-1])
        ]
        weights = np.stack(source_weights, axis=-1)
        weights = source_weights.max(axis=-1)
        return weights

    def _load_audio_file(self, file_path: str) -> AudioSignal:
        """Loads audio file at given path. Uses wavfile.read if the extension is a wav
        file as this is considerably faster than using librosa to load the audio file.
        Otherwise, uses the nussl AudioSignal file loader, which just calls 
        librosa.load.

        Args:
            file_path - relative or absolute path to file to load

        Returns:
            AudioSignal object
        """
        if os.path.splitext(file_path)[-1] == '.wav':
            audio, rate = sf.read(file_path)
            audio_signal = AudioSignal(audio_data_array=audio, sample_rate=self.options['sample_rate'])
        else:
            audio_signal = AudioSignal(file_path, sample_rate=self.options['sample_rate'])
        audio_signal.path_to_input_file = file_path
        audio_signal.stft_params.window_length = self.options['n_fft']
        audio_signal.stft_params.hop_length = self.options['hop_length']
        return audio_signal

    def inspect(self, i):
        """Useful for inspecting if a dataset implementation is working inside of a 
        Jupyter notebook. It prints every AudioSignal object loaded by load_audio_files,
        visualizes the output of the network, and embeds the audio files via 
        jupyter_utils.embed_audio.

        Args:
            i: Index of the dataset to visualize.
        
        Returns:
            None. Visualizes via plots and audio files.
        """
        items = self.load_audio_files(self.files[i])
        output = self.construct_input_output(items[0], items[1])
        output['weights'] = self.get_weights(
            output,
            self.options['weight_type']
        )

        for item in items:
            print(item)
        
        print('Mixture + original sources')
        jupyter_utils.embed_audio(items[0])
        for s in items[1]:
            jupyter_utils.embed_audio(s)

        print('Sources masked from mixture')
        for j in range(output['assignments'].shape[-1]):
            mask = SoftMask(output['assignments'][:, :, :, j])
            items[0].stft()
            signal = items[0].apply_mask(mask)
            signal.istft(overwrite=True, truncate_to_length=items[0].signal_length)
            jupyter_utils.embed_audio(signal)

        plt.subplot(211)
        plt.grid(False)
        plt.imshow(output['log_spectrogram'].mean(axis=-1), origin='lower', aspect='auto')
        plt.title('Mixture spectrogram')

        plt.subplot(212)
        plt.grid(False)
        plt.imshow(np.argmax(output['assignments'], axis=-1).mean(axis=-1), origin='lower', aspect='auto')
        plt.title('Assignments')
